{"ast":null,"code":"const Shop = require('../models/Shop'); // Import the Shop model\nconst bcrypt = require('bcryptjs'); // For hashing passwords\nconst fs = require('fs');\nconst path = require('path');\nconst Booking = require('../models/Booking');\n// Controller for registering a new shop\nexports.registershop = async (req, res) => {\n  const {\n    owner,\n    email,\n    password\n  } = req.body;\n  try {\n    // Check if the shop email already exists\n    const existingShop = await Shop.findOne({\n      email\n    });\n    if (existingShop) {\n      return res.status(400).json({\n        message: 'Shop with this email already exists.'\n      });\n    }\n\n    // Hash the password\n    const hashedPassword = await bcrypt.hash(password, 10);\n\n    // Create a new shop instance\n    const newShop = new Shop({\n      owner,\n      email,\n      password: hashedPassword\n    });\n\n    // Save the new shop in the database\n    await newShop.save();\n    res.status(201).json({\n      message: 'Shop registered successfully',\n      shop: newShop\n    });\n  } catch (error) {\n    console.error(error);\n    res.status(500).json({\n      message: 'Server error. Please try again later.'\n    });\n  }\n};\nexports.loginshop = async (req, res) => {\n  const {\n    email,\n    password\n  } = req.body;\n  if (!email || !password) {\n    return res.status(400).json({\n      msg: 'Email and password are required'\n    });\n  }\n  try {\n    // Find the shop by email\n    const shop = await Shop.findOne({\n      email\n    }).exec();\n    if (!shop) {\n      return res.status(400).json({\n        msg: 'Invalid credentials'\n      });\n    }\n\n    // Check the password\n    const isMatch = await bcrypt.compare(password, shop.password);\n    if (!isMatch) {\n      return res.status(400).json({\n        msg: 'Invalid credentials'\n      });\n    }\n\n    // Store shop details in the session\n    req.session.shop = shop;\n    console.log('Session created:', req.session.shop);\n\n    // Set the session cookie (remove secure: true for development)\n    res.cookie('sessionId', req.session.id, {\n      httpOnly: true,\n      secure: false,\n      sameSite: 'None'\n    });\n    res.status(200).json({\n      msg: 'Login Successful'\n    });\n  } catch (err) {\n    console.error(err.message);\n    res.status(500).json({\n      msg: 'Server error'\n    });\n  }\n};\nexports.checkshopsession = (req, res) => {\n  console.log('Session object:', req.session); // Debugging session object\n\n  if (req.session.shop) {\n    console.log('Session exists');\n    const shop = req.session.shop;\n    if (shop.availablesports && shop.availablesports.length > 0) {\n      shop.availablesports = shop.availablesports.map(sport => {\n        try {\n          const filepath = path.join(__dirname, '..', sport.image);\n          const imageBuffer = fs.readFileSync(filepath);\n          // Convert the image to a base64 string with MIME type\n          sport.getimage = `data:image/jpeg;base64,${imageBuffer.toString('base64')}`;\n        } catch (imageError) {\n          console.error(`Error reading image for ${sport.groundname}:`, imageError);\n          sport.getimage = ''; // Push an empty string if image not found\n        }\n        return sport;\n      });\n    } else {\n      console.log('No available sports found for this shop.');\n    }\n    res.status(200).json({\n      msg: 'Shop session exists',\n      shop: req.session.shop\n    });\n  } else {\n    console.log('No session found');\n    res.status(400).json({\n      msg: \"Session does not exist\"\n    });\n  }\n};\nexports.updateshop = async (req, res) => {\n  if (!req.session.shop) {\n    return res.status(401).json({\n      msg: 'No shop logged in'\n    });\n  }\n  const shopId = req.session.shop._id;\n  const {\n    shopname,\n    address\n  } = req.body;\n  try {\n    const updatedShop = await Shop.findByIdAndUpdate(shopId, {\n      shopname,\n      address\n    }, {\n      new: true\n    });\n    if (!updatedShop) {\n      return res.status(404).json({\n        msg: 'Shop not found'\n      });\n    }\n    req.session.shop = updatedShop; // Optionally update session data\n    res.status(200).json({\n      msg: 'Shop details updated successfully',\n      updatedShop\n    });\n  } catch (err) {\n    console.error(err.message);\n    res.status(500).json({\n      msg: 'Server error'\n    });\n  }\n};\nexports.addground = async (req, res) => {\n  const {\n    groundname,\n    priceperhour,\n    maxplayers,\n    groundLength,\n    groundwidth,\n    facilities,\n    surfaceType,\n    availability\n  } = req.body;\n  const image = req.file; // Multer stores the uploaded file in req.file\n\n  // Parse the availability from the request\n  let parsedAvailability;\n  console.log(req.body);\n  console.log(availability);\n  try {\n    // Check if availability is a string and parse it\n    if (typeof availability === 'string') {\n      parsedAvailability = JSON.parse(availability);\n    } else {\n      parsedAvailability = availability;\n    }\n  } catch (error) {\n    return res.status(400).json({\n      msg: 'Invalid availability data'\n    });\n  }\n\n  // Validate the required fields\n  if (!groundname || !priceperhour || !maxplayers || !groundLength || !groundwidth || !facilities || !surfaceType) {\n    return res.status(400).json({\n      msg: 'All fields are required'\n    });\n  }\n  try {\n    // Find the shop by user session or ID (you may want to adapt this)\n    const shopId = req.session.shop._id; // Assuming you store shop ID in session\n    const shop = await Shop.findById(shopId);\n    if (!shop) {\n      return res.status(404).json({\n        msg: 'Shop not found'\n      });\n    }\n\n    // Determine the file extension from the mimetype\n    let fileExtension = '';\n    if (image) {\n      // Map mimetype to file extension\n      const mimeToExt = {\n        'image/jpeg': 'jpg',\n        'image/png': 'png',\n        'image/gif': 'gif',\n        'image/webp': 'webp'\n      };\n      fileExtension = mimeToExt[image.mimetype] || ''; // Default to empty if unknown mimetype\n    }\n\n    // Construct the image path if image exists\n    const imagePath = `/public/images/${shopId}${groundname}.${fileExtension}`;\n\n    // Create a new ground object\n    const newGround = {\n      groundname,\n      priceperhour,\n      maxplayers,\n      grounddimensions: {\n        length: groundLength,\n        width: groundwidth\n      },\n      facilities: facilities.split(',').map(facility => facility.trim()),\n      // Convert to array\n      surfacetype: surfaceType,\n      availability: parsedAvailability,\n      // Use parsed availability\n      image: imagePath,\n      // Save the image path if it exists\n      status: 'Active',\n      // Default status\n      verify: false,\n      // Default verification\n      appliedforverification: false // Default verification application\n    };\n\n    // Push the new ground to the shop's availablesports array\n    shop.availablesports.push(newGround);\n    await shop.save();\n    req.session.shop = shop;\n    res.status(201).json({\n      msg: 'Ground added successfully!',\n      shop\n    });\n  } catch (error) {\n    console.error('Error adding ground:', error);\n    res.status(500).json({\n      msg: 'Server error'\n    });\n  }\n};\n\n// Adjust the path to your Shop model\n\nexports.loadVenues = async (req, res) => {\n  try {\n    // Fetch all shops with at least one verified sport ground\n    console.log('hi');\n    const shopsWithVenues = await Shop.find({\n      'availablesports.verify': true\n    }).exec();\n\n    // Create a response format for venues\n    const venueData = shopsWithVenues.map(shop => {\n      // Filter only verified sports grounds\n      const verifiedSports = shop.availablesports.filter(sport => sport.verify);\n\n      // Return only if there are verified sports grounds\n      return verifiedSports.map(sport => {\n        // Construct the image path\n        const imagePath = path.join(__dirname, '..', sport.image); // Adjust path as needed\n        let imageBase64 = '';\n        // Read the image file and convert to base64\n        try {\n          const imageBuffer = fs.readFileSync(imagePath);\n          imageBase64 = imageBuffer.toString('base64');\n        } catch (imageError) {\n          console.error(`Error reading image for ${sport.groundname}:`, imageError);\n          imageBase64 = ''; // Default to an empty string if image not found\n        }\n\n        // Return venue data including ground dimensions, availability, and facilities\n        return {\n          name: shop.shopname,\n          address: shop.address,\n          image: `data:image/jpeg;base64,${imageBase64}`,\n          // Include base64 encoded image\n          groundname: sport.groundname,\n          priceperhour: sport.priceperhour,\n          maxplayers: sport.maxplayers,\n          surfacetype: sport.surfacetype,\n          status: sport.status,\n          grounddimensions: sport.grounddimensions,\n          availability: sport.availability,\n          facilities: sport.facilities\n        };\n      });\n    }).flat(); // Flatten the array of arrays into a single array\n\n    // Check if any verified venues were found\n    if (venueData.length === 0) {\n      return res.status(404).json({\n        message: 'No verified venues found'\n      });\n    }\n\n    // Send the venues data in response\n    res.status(200).json(venueData);\n  } catch (error) {\n    console.error('Error fetching venues:', error);\n    res.status(500).json({\n      message: 'Internal server error'\n    });\n  }\n};\nexports.loadGround = async (req, res) => {\n  try {\n    const {\n      name\n    } = req.body;\n    const shopname = name.slice();\n    // Find the ground(s) that match the venue name\n    const grounds = await ShopSport.find({\n      groundname: name\n    }).populate('sport') // Populate to get details of the sport\n    .exec();\n    if (!grounds || grounds.length === 0) {\n      return res.status(404).json({\n        message: 'No grounds found for the specified venue.'\n      });\n    }\n    res.status(200).json(grounds);\n  } catch (error) {\n    console.error('Error loading ground:', error);\n    res.status(500).json({\n      message: 'An error occurred while loading the ground.'\n    });\n  }\n};\n\n// Create a new booking\nexports.createBooking = async (req, res) => {\n  try {\n    const {\n      shop,\n      date,\n      timeSlot,\n      amountPaid\n    } = req.body;\n    const user = req.session.user;\n\n    // Create a new booking object\n    const newBooking = new Booking({\n      user,\n      shop,\n      sport,\n      date,\n      timeSlot,\n      amountPaid\n    });\n\n    // Save booking to database\n    await newBooking.save();\n    res.status(201).json({\n      message: 'Booking created successfully!',\n      booking: newBooking\n    });\n  } catch (error) {\n    res.status(500).json({\n      message: 'Error creating booking',\n      error: error.message\n    });\n  }\n};\n\n// Fetch all bookings\nexports.getAllBookings = async (req, res) => {\n  try {\n    const bookings = await Booking.find().populate('user', 'username email') // Populate user details\n    .populate('shop', 'shopname address') // Populate shop details\n    .populate('sport', 'groundname'); // Populate sport details\n    res.status(200).json(bookings);\n  } catch (error) {\n    res.status(500).json({\n      message: 'Error fetching bookings',\n      error: error.message\n    });\n  }\n};\n\n// Fetch bookings by user\nexports.getBookingsByUser = async (req, res) => {\n  try {\n    const {\n      userId\n    } = req.params;\n    const bookings = await Booking.find({\n      user: userId\n    }).populate('shop', 'shopname address').populate('sport', 'groundname');\n    res.status(200).json(bookings);\n  } catch (error) {\n    res.status(500).json({\n      message: 'Error fetching bookings for user',\n      error: error.message\n    });\n  }\n};\n\n// Update a booking\nexports.updateBooking = async (req, res) => {\n  try {\n    const {\n      bookingId\n    } = req.params;\n    const updates = req.body;\n    const updatedBooking = await Booking.findByIdAndUpdate(bookingId, updates, {\n      new: true\n    });\n    if (!updatedBooking) {\n      return res.status(404).json({\n        message: 'Booking not found'\n      });\n    }\n    res.status(200).json({\n      message: 'Booking updated successfully',\n      booking: updatedBooking\n    });\n  } catch (error) {\n    res.status(500).json({\n      message: 'Error updating booking',\n      error: error.message\n    });\n  }\n};\n\n// Cancel a booking\nexports.cancelBooking = async (req, res) => {\n  try {\n    const {\n      bookingId\n    } = req.params;\n    const {\n      cancellationReason\n    } = req.body;\n    const cancelledBooking = await Booking.findByIdAndUpdate(bookingId, {\n      status: 'Cancelled',\n      cancellationReason,\n      cancellationDate: new Date()\n    }, {\n      new: true\n    });\n    if (!cancelledBooking) {\n      return res.status(404).json({\n        message: 'Booking not found'\n      });\n    }\n    res.status(200).json({\n      message: 'Booking cancelled successfully',\n      booking: cancelledBooking\n    });\n  } catch (error) {\n    res.status(500).json({\n      message: 'Error cancelling booking',\n      error: error.message\n    });\n  }\n};\n\n// Add feedback for a booking\nexports.addFeedback = async (req, res) => {\n  try {\n    const {\n      bookingId\n    } = req.params;\n    const {\n      rating,\n      comment\n    } = req.body;\n    const booking = await Booking.findByIdAndUpdate(bookingId, {\n      feedback: {\n        rating,\n        comment,\n        feedbackDate: new Date()\n      }\n    }, {\n      new: true\n    });\n    if (!booking) {\n      return res.status(404).json({\n        message: 'Booking not found'\n      });\n    }\n    res.status(200).json({\n      message: 'Feedback added successfully',\n      booking\n    });\n  } catch (error) {\n    res.status(500).json({\n      message: 'Error adding feedback',\n      error: error.message\n    });\n  }\n};","map":{"version":3,"names":["Shop","require","bcrypt","fs","path","Booking","exports","registershop","req","res","owner","email","password","body","existingShop","findOne","status","json","message","hashedPassword","hash","newShop","save","shop","error","console","loginshop","msg","exec","isMatch","compare","session","log","cookie","id","httpOnly","secure","sameSite","err","checkshopsession","availablesports","length","map","sport","filepath","join","__dirname","image","imageBuffer","readFileSync","getimage","toString","imageError","groundname","updateshop","shopId","_id","shopname","address","updatedShop","findByIdAndUpdate","new","addground","priceperhour","maxplayers","groundLength","groundwidth","facilities","surfaceType","availability","file","parsedAvailability","JSON","parse","findById","fileExtension","mimeToExt","mimetype","imagePath","newGround","grounddimensions","width","split","facility","trim","surfacetype","verify","appliedforverification","push","loadVenues","shopsWithVenues","find","venueData","verifiedSports","filter","imageBase64","name","flat","loadGround","slice","grounds","ShopSport","populate","createBooking","date","timeSlot","amountPaid","user","newBooking","booking","getAllBookings","bookings","getBookingsByUser","userId","params","updateBooking","bookingId","updates","updatedBooking","cancelBooking","cancellationReason","cancelledBooking","cancellationDate","Date","addFeedback","rating","comment","feedback","feedbackDate"],"sources":["C:/Users/Bhaskar/Desktop/GITPRAC/fedproject/my-react-app/src/Shop/ShopDashboard.jsx"],"sourcesContent":["const Shop = require('../models/Shop'); // Import the Shop model\r\nconst bcrypt = require('bcryptjs'); // For hashing passwords\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst Booking = require('../models/Booking');\r\n// Controller for registering a new shop\r\nexports.registershop = async (req, res) => {\r\n  const { owner,email, password } = req.body;\r\n\r\n  try {\r\n    // Check if the shop email already exists\r\n    const existingShop = await Shop.findOne({ email });\r\n    if (existingShop) {\r\n      return res.status(400).json({ message: 'Shop with this email already exists.' });\r\n    }\r\n\r\n    // Hash the password\r\n    const hashedPassword = await bcrypt.hash(password, 10);\r\n\r\n    // Create a new shop instance\r\n    const newShop = new Shop({\r\n      owner,\r\n      email,\r\n      password: hashedPassword\r\n    });\r\n\r\n    // Save the new shop in the database\r\n    await newShop.save();\r\n\r\n    res.status(201).json({ message: 'Shop registered successfully', shop: newShop });\r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Server error. Please try again later.' });\r\n  }\r\n};\r\nexports.loginshop = async (req, res) => {\r\n    const { email, password } = req.body;\r\n\r\n    if (!email || !password) {\r\n        return res.status(400).json({ msg: 'Email and password are required' });\r\n    }\r\n\r\n    try {\r\n        // Find the shop by email\r\n        const shop = await Shop.findOne({ email }).exec();\r\n        if (!shop) {\r\n            return res.status(400).json({ msg: 'Invalid credentials' });\r\n        }\r\n\r\n        // Check the password\r\n        const isMatch = await bcrypt.compare(password, shop.password);\r\n        if (!isMatch) {\r\n            return res.status(400).json({ msg: 'Invalid credentials' });\r\n        }\r\n\r\n        // Store shop details in the session\r\n        req.session.shop = shop;\r\n        console.log('Session created:', req.session.shop);\r\n\r\n        // Set the session cookie (remove secure: true for development)\r\n        res.cookie('sessionId', req.session.id, { httpOnly: true, secure: false, sameSite: 'None' });\r\n        res.status(200).json({ msg: 'Login Successful' });\r\n    } catch (err) {\r\n        console.error(err.message);\r\n        res.status(500).json({ msg: 'Server error' });\r\n    }\r\n};\r\n\r\n\r\nexports.checkshopsession = (req, res) => {\r\n    console.log('Session object:', req.session); // Debugging session object\r\n\r\n    if (req.session.shop) {\r\n        console.log('Session exists');\r\n\r\n        const shop = req.session.shop;\r\n\r\n        if (shop.availablesports && shop.availablesports.length > 0) {\r\n            shop.availablesports = shop.availablesports.map((sport) => {\r\n                try {\r\n                    const filepath = path.join(__dirname, '..', sport.image);\r\n                    const imageBuffer = fs.readFileSync(filepath);\r\n                    // Convert the image to a base64 string with MIME type\r\n                    sport.getimage = `data:image/jpeg;base64,${imageBuffer.toString('base64')}`;\r\n                } catch (imageError) {\r\n                    console.error(`Error reading image for ${sport.groundname}:`, imageError);\r\n                    sport.getimage = ''; // Push an empty string if image not found\r\n                }\r\n                return sport;\r\n            });\r\n        } else {\r\n            console.log('No available sports found for this shop.');\r\n        }\r\n\r\n        res.status(200).json({ msg: 'Shop session exists', shop: req.session.shop });\r\n    } else {\r\n        console.log('No session found');\r\n        res.status(400).json({ msg: \"Session does not exist\" });\r\n    }\r\n};\r\n\r\n\r\nexports.updateshop = async (req, res) => {\r\n    if (!req.session.shop) {\r\n        return res.status(401).json({ msg: 'No shop logged in' });\r\n    }\r\n\r\n    const shopId = req.session.shop._id;\r\n    const { shopname, address } = req.body;\r\n\r\n    try {\r\n        const updatedShop = await Shop.findByIdAndUpdate(shopId, { shopname, address }, { new: true });\r\n\r\n        if (!updatedShop) {\r\n            return res.status(404).json({ msg: 'Shop not found' });\r\n        }\r\n\r\n        req.session.shop = updatedShop; // Optionally update session data\r\n        res.status(200).json({ msg: 'Shop details updated successfully', updatedShop });\r\n    } catch (err) {\r\n        console.error(err.message);\r\n        res.status(500).json({ msg: 'Server error' });\r\n    }\r\n};\r\n\r\n\r\nexports.addground = async (req, res) => {\r\n    const { groundname, priceperhour, maxplayers, groundLength, groundwidth, facilities, surfaceType, availability } = req.body;\r\n    const image = req.file; // Multer stores the uploaded file in req.file\r\n\r\n    // Parse the availability from the request\r\n    let parsedAvailability;\r\n    console.log(req.body);\r\n    console.log(availability);\r\n\r\n    try {\r\n        // Check if availability is a string and parse it\r\n        if (typeof availability === 'string') {\r\n            parsedAvailability = JSON.parse(availability);\r\n        } else {\r\n            parsedAvailability = availability;\r\n        }\r\n    } catch (error) {\r\n        return res.status(400).json({ msg: 'Invalid availability data' });\r\n    }\r\n\r\n    // Validate the required fields\r\n    if (!groundname || !priceperhour || !maxplayers || !groundLength || !groundwidth || !facilities || !surfaceType) {\r\n        return res.status(400).json({ msg: 'All fields are required' });\r\n    }\r\n\r\n    try {\r\n        // Find the shop by user session or ID (you may want to adapt this)\r\n        const shopId = req.session.shop._id; // Assuming you store shop ID in session\r\n        const shop = await Shop.findById(shopId);\r\n\r\n        if (!shop) {\r\n            return res.status(404).json({ msg: 'Shop not found' });\r\n        }\r\n\r\n        // Determine the file extension from the mimetype\r\n        let fileExtension = '';\r\n        if (image) {\r\n            // Map mimetype to file extension\r\n            const mimeToExt = {\r\n                'image/jpeg': 'jpg',\r\n                'image/png': 'png',\r\n                'image/gif': 'gif',\r\n                'image/webp': 'webp'\r\n            };\r\n\r\n            fileExtension = mimeToExt[image.mimetype] || ''; // Default to empty if unknown mimetype\r\n        }\r\n\r\n        // Construct the image path if image exists\r\n        const imagePath = `/public/images/${shopId}${groundname}.${fileExtension}` ;\r\n\r\n        // Create a new ground object\r\n        const newGround = {\r\n            groundname,\r\n            priceperhour,\r\n            maxplayers,\r\n            grounddimensions: {\r\n                length: groundLength,\r\n                width: groundwidth,\r\n            },\r\n            facilities: facilities.split(',').map(facility => facility.trim()), // Convert to array\r\n            surfacetype: surfaceType,\r\n            availability: parsedAvailability, // Use parsed availability\r\n            image: imagePath, // Save the image path if it exists\r\n            status: 'Active', // Default status\r\n            verify: false,    // Default verification\r\n            appliedforverification: false // Default verification application\r\n        };\r\n\r\n        // Push the new ground to the shop's availablesports array\r\n        shop.availablesports.push(newGround);\r\n        await shop.save();\r\n        req.session.shop=shop;\r\n\r\n        res.status(201).json({ msg: 'Ground added successfully!', shop });\r\n    } catch (error) {\r\n        console.error('Error adding ground:', error);\r\n        res.status(500).json({ msg: 'Server error' });\r\n    }\r\n};\r\n\r\n\r\n // Adjust the path to your Shop model\r\n\r\nexports.loadVenues = async (req, res) => {\r\n  try {\r\n    // Fetch all shops with at least one verified sport ground\r\n    console.log('hi');\r\n    const shopsWithVenues = await Shop.find({ 'availablesports.verify': true }).exec();\r\n\r\n    // Create a response format for venues\r\n    const venueData = shopsWithVenues.map(shop => {\r\n      // Filter only verified sports grounds\r\n      const verifiedSports = shop.availablesports.filter(sport => sport.verify);\r\n\r\n      // Return only if there are verified sports grounds\r\n      return verifiedSports.map(sport => {\r\n        // Construct the image path\r\n        const imagePath = path.join(__dirname, '..', sport.image); // Adjust path as needed\r\n        let imageBase64 = '';\r\n        // Read the image file and convert to base64\r\n        try {\r\n          const imageBuffer = fs.readFileSync(imagePath);\r\n          imageBase64 = imageBuffer.toString('base64');\r\n        } catch (imageError) {\r\n          console.error(`Error reading image for ${sport.groundname}:`, imageError);\r\n          imageBase64 = ''; // Default to an empty string if image not found\r\n        }\r\n\r\n        // Return venue data including ground dimensions, availability, and facilities\r\n        return {\r\n          name: shop.shopname,\r\n          address: shop.address,\r\n          image: `data:image/jpeg;base64,${imageBase64}`, // Include base64 encoded image\r\n          groundname: sport.groundname,\r\n          priceperhour: sport.priceperhour,\r\n          maxplayers: sport.maxplayers,\r\n          surfacetype: sport.surfacetype,\r\n          status: sport.status,\r\n          grounddimensions: sport.grounddimensions,\r\n          availability: sport.availability,\r\n          facilities: sport.facilities\r\n        };\r\n      });\r\n    }).flat(); // Flatten the array of arrays into a single array\r\n\r\n    // Check if any verified venues were found\r\n    if (venueData.length === 0) {\r\n      return res.status(404).json({ message: 'No verified venues found' });\r\n    }\r\n\r\n    // Send the venues data in response\r\n    res.status(200).json(venueData);\r\n  } catch (error) {\r\n    console.error('Error fetching venues:', error);\r\n    res.status(500).json({ message: 'Internal server error' });\r\n  }\r\n};\r\nexports.loadGround = async (req, res) => {\r\n    try {\r\n      const { name } = req.body;\r\n      const shopname=name.slice()\r\n      // Find the ground(s) that match the venue name\r\n      const grounds = await ShopSport.find({ groundname: name })\r\n        .populate('sport') // Populate to get details of the sport\r\n        .exec();\r\n  \r\n      if (!grounds || grounds.length === 0) {\r\n        return res.status(404).json({ message: 'No grounds found for the specified venue.' });\r\n      }\r\n  \r\n      res.status(200).json(grounds);\r\n    } catch (error) {\r\n      console.error('Error loading ground:', error);\r\n      res.status(500).json({ message: 'An error occurred while loading the ground.' });\r\n    }\r\n  };\r\n\r\n\r\n// Create a new booking\r\nexports.createBooking = async (req, res) => {\r\n    try {\r\n        const { shop,date, timeSlot, amountPaid } = req.body;\r\n        const user=req.session.user;\r\n\r\n        // Create a new booking object\r\n        const newBooking = new Booking({\r\n            user,\r\n            shop,\r\n            sport,\r\n            date,\r\n            timeSlot,\r\n            amountPaid\r\n        });\r\n\r\n        // Save booking to database\r\n        await newBooking.save();\r\n        res.status(201).json({ message: 'Booking created successfully!', booking: newBooking });\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Error creating booking', error: error.message });\r\n    }\r\n};\r\n\r\n// Fetch all bookings\r\nexports.getAllBookings = async (req, res) => {\r\n    try {\r\n        const bookings = await Booking.find()\r\n            .populate('user', 'username email') // Populate user details\r\n            .populate('shop', 'shopname address') // Populate shop details\r\n            .populate('sport', 'groundname'); // Populate sport details\r\n        res.status(200).json(bookings);\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Error fetching bookings', error: error.message });\r\n    }\r\n};\r\n\r\n// Fetch bookings by user\r\nexports.getBookingsByUser = async (req, res) => {\r\n    try {\r\n        const { userId } = req.params;\r\n        const bookings = await Booking.find({ user: userId })\r\n            .populate('shop', 'shopname address')\r\n            .populate('sport', 'groundname');\r\n        res.status(200).json(bookings);\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Error fetching bookings for user', error: error.message });\r\n    }\r\n};\r\n\r\n// Update a booking\r\nexports.updateBooking = async (req, res) => {\r\n    try {\r\n        const { bookingId } = req.params;\r\n        const updates = req.body;\r\n        const updatedBooking = await Booking.findByIdAndUpdate(bookingId, updates, { new: true });\r\n\r\n        if (!updatedBooking) {\r\n            return res.status(404).json({ message: 'Booking not found' });\r\n        }\r\n\r\n        res.status(200).json({ message: 'Booking updated successfully', booking: updatedBooking });\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Error updating booking', error: error.message });\r\n    }\r\n};\r\n\r\n// Cancel a booking\r\nexports.cancelBooking = async (req, res) => {\r\n    try {\r\n        const { bookingId } = req.params;\r\n        const { cancellationReason } = req.body;\r\n\r\n        const cancelledBooking = await Booking.findByIdAndUpdate(\r\n            bookingId,\r\n            { status: 'Cancelled', cancellationReason, cancellationDate: new Date() },\r\n            { new: true }\r\n        );\r\n\r\n        if (!cancelledBooking) {\r\n            return res.status(404).json({ message: 'Booking not found' });\r\n        }\r\n\r\n        res.status(200).json({ message: 'Booking cancelled successfully', booking: cancelledBooking });\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Error cancelling booking', error: error.message });\r\n    }\r\n};\r\n\r\n// Add feedback for a booking\r\nexports.addFeedback = async (req, res) => {\r\n    try {\r\n        const { bookingId } = req.params;\r\n        const { rating, comment } = req.body;\r\n\r\n        const booking = await Booking.findByIdAndUpdate(\r\n            bookingId,\r\n            { feedback: { rating, comment, feedbackDate: new Date() } },\r\n            { new: true }\r\n        );\r\n\r\n        if (!booking) {\r\n            return res.status(404).json({ message: 'Booking not found' });\r\n        }\r\n\r\n        res.status(200).json({ message: 'Feedback added successfully', booking });\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Error adding feedback', error: error.message });\r\n    }\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}